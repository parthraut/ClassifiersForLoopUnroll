- Loop unrolling pass (pass to set unroll factor)
- Inserting Timing Code pass (insert timing code for each loop)

- Deciding on what features to use for model
    - write a pass that extracts features from each loop, stores in a json object shown below:

- Preprocessing script and model in python 
    - take in the json obj and train the model


output of dataset:


json obj:
{
    filename: [
        {
            features: {
                feature1: <value>,
                feature2: <value>,
                feature3: <value>,
                ...

            },
            label_info: [
                <list of execution times for LUF = 1>,
                <list of execution times for LUF = 2>,
                <list of execution times for LUF = 4>,
                <list of execution times for LUF = 8>,
                ...
            ]
        },
        ...
    ],
    ...

}

features:

 # MIT paper
 
 ## feature vector 1
 - number of operands
 - live range size
 - critical path length
 - number of operations
 - loop trip count
 
 ## feature vector 2
 - number of floating point operations
 - loop nest level
 - number of operands
 - number of branches
 - number of memory operations

 # High Level Synthesis
 - Critical Path
 - Loop Trip Count
 - Has Loop Carried Dependencies
 - number of loads
 - number of stores

# overall baseline features
2. live range size
3. critical path length
---------------
1. number of operands * --> (MIT) number of rhs registers
4. number of operations ** --> (MIT & HL) instruction count
5. loop trip count **
6. number of floating point operations **
7. loop nest level **
8. number of branches **
9. number of memory operations **
10. has loop carried Dependencies **
11. number of loads **
12. number of stores **


 our features:
 1. trip count
 2. instruction counts (num alui, aluf, load, store, mem, br, other, total) && operand count && array reads/write/accesses
 3. total number of intra-loop carried dependencies && has loop carried dependencies boolean && max intra-loop dependency distance
 4. loop nest level
 5. resMII (3 different vals - 111, 211, 121)

- 
- new features:
 - recMII (ignore)
 - distance of Dependencies (ignore)
 - # of unique arrays accessed (ignore)
 - Small Iteration Count Heuristic (ignore)
 ------------------------------------------------------------------
- ResMII ** (3 different resource unit combos hardcoded - (111), (211), and (121))
- number of intra loop dependencies **
- maximum intra-loop dependency distance
- # of array reads
- # of array writes
- # of array accesses


 if cant figure out recMII and distance dep: *
    - number of loop carried dependencies *

 - (weighted, if possible) average path length
    - if llvm predicts branch prob without profile data, weight avg

recMII vs ResMII - from lecture (resource constrained vs path contrained loop)
distances of Dependencies



LLVM -> cost analysis, analysis, heuristics -> ML