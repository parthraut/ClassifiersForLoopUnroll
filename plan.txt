- Loop unrolling pass (pass to set unroll factor)
- Inserting Timing Code pass (insert timing code for each loop)

- Deciding on what features to use for model
    - write a pass that extracts features from each loop, stores in a json object shown below:

- Preprocessing script and model in python 
    - take in the json obj and train the model


output of dataset:


json obj:
{
    filename: [
        {
            features: {
                feature1: <value>,
                feature2: <value>,
                feature3: <value>,
                ...

            },
            label_info: [
                <list of execution times for LUF = 1>,
                <list of execution times for LUF = 2>,
                <list of execution times for LUF = 4>,
                <list of execution times for LUF = 8>,
                ...
            ]
        },
        ...
    ],
    ...

}

features:

 # MIT paper
 
 ## feature vector 1
 - number of operands
 - live range size
 - critical path length
 - number of operations
 - loop trip count
 
 ## feature vector 2
 - number of floating point operations
 - loop nest level
 - number of operands
 - number of branches
 - number of memory operations

 # High Level Synthesis
 - Critical Path
 - Loop Trip Count
 - Has Loop Carried Dependencies
 - number of loads
 - number of stores

# overall baseline features
1. number of operands *
2. live range size
3. critical path length
4. number of operations *
5. loop trip count *
6. number of floating point operations **
7. loop nest level *
8. number of branches **
9. number of memory operations **
10. has loop carried Dependencies *
11. number of loads **
12. number of stores **
* 11 and 12 can be added to create 10

 our features:

- 
- new features:
 - recMII *
 - ResMII * (3 different resource unit combos hardcoded -)
 - distance of Dependencies *
 - number of intra loop dependencies
 - # of array reads
 - # of array writes
 - # of array accesses
 - # of unique arrays accessed
 - Maximum Dependency distance
 - Small Iteration Count Heuristic

 if cant figure out recMII and distance dep: *
    - number of loop carried dependencies *

 - (weighted, if possible) average path length
    - if llvm predicts branch prob without profile data, weight avg

recMII vs ResMII - from lecture (resource constrained vs path contrained loop)
distances of Dependencies



LLVM -> cost analysis, analysis, heuristics -> ML